main.jsx

// src/main.jsx

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./assets/scss/style.scss"; // SCSS ìŠ¤íƒ€ì¼ íŒŒì¼ import

/**
 * main.jsx
 * - React ì•±ì˜ ì§„ì…ì 
 * - App ì»´í¬ë„ŒíŠ¸ë¥¼ root DOM ìš”ì†Œì— ë Œë”ë§
 */
ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

quiz.jsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { choiceQuizzes, fillQuizzes, allQuizzes } from './quizData';

const TIME_LIMIT = 30;

// ë°°ì—´ ì„ê¸° í•¨ìˆ˜ (shuffle)
function shuffleArray(array) {
  return [...array].sort(() => Math.random() - 0.5);
}

// ê°ê´€ì‹ ë¬¸ì œ ì˜µì…˜ ì„ê¸° + ì •ë‹µ ì¸ë±ìŠ¤ ë³´ì • í•¨ìˆ˜
function prepareShuffledQuizData(data) {
  return data.map((q) => {
    if (q.type === "fill") return q; // ì£¼ê´€ì‹ ë¬¸ì œëŠ” ê·¸ëŒ€ë¡œ
    const correctValue = q.options[q.answer];
    const shuffled = shuffleArray(q.options);
    const newAnswer = shuffled.indexOf(correctValue);
    return { ...q, options: shuffled, answer: newAnswer };
  });
}

// ì¹­ì°¬ ë©”ì‹œì§€
const positiveMessages = [
  "ì˜í–ˆì–´ìš”! ğŸ‘",
  "ë©‹ì§„ ì„ íƒì´ì—ìš”! ğŸ‘",
  "ê³„ì† ì˜í•´ìš”! ğŸ’ª",
  "í›Œë¥­í•´ìš”! ğŸ‰",
];

// ì¬ë„ì „ ë©”ì‹œì§€
const retryMessages = [
  "ë‹¤ì‹œ í•œ ë²ˆ ë„ì „í•´ë³´ì„¸ìš”! ğŸ”„",
  "í¬ê¸°í•˜ì§€ ë§ê³ ! âœŠ",
  "ì¡°ê¸ˆë§Œ ë” í˜ë‚´ìš”! ğŸ˜Š",
];

export default function Quiz() {
  // ëª¨ë“œ ìƒíƒœ (choice, fill, mixed)
  const [mode, setMode] = useState(null);

  // í€´ì¦ˆ ë°ì´í„°, í˜„ì¬ ë¬¸ì œ ì¸ë±ìŠ¤ ë“± ìƒíƒœë“¤
  const [quizData, setQuizData] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selected, setSelected] = useState(null);
  const [fillInput, setFillInput] = useState([]);
  const [showAnswer, setShowAnswer] = useState(false);
  const [score, setScore] = useState(0);
  const [answerHistory, setAnswerHistory] = useState([]);
  const [timeLeft, setTimeLeft] = useState(TIME_LIMIT);
  const [quizEndTime, setQuizEndTime] = useState(null);
  const [message, setMessage] = useState("");
  const [gifSrc, setGifSrc] = useState("");
  const [showTryAgainBtn, setShowTryAgainBtn] = useState(false);
  const [showNextBtn, setShowNextBtn] = useState(false);
  const [canRetry, setCanRetry] = useState(false);

  const quizStartTime = useRef(Date.now());
  const timerId = useRef(null);

  // í€´ì¦ˆ ëª¨ë“œë³„ ë°ì´í„° ë§¤í•‘
  const multipleChoiceQuiz = choiceQuizzes;
  const fillInTheBlankQuiz = fillQuizzes;
  const mixedQuiz = allQuizzes;

  const current = quizData[currentIndex];
  const isFillQuestion = current?.type === "fill";

  const allDone = quizEndTime !== null;
  const allCorrect = allDone && score === quizData.length;
  const allWrong = allDone && score === 0;

  // GIF ìƒíƒœë³„ ì„¤ì • í•¨ìˆ˜
  const setGifByResult = (type) => {
    switch (type) {
      case "correct":
        setGifSrc("/images/correct.gif");
        break;
      case "try-again":
        setGifSrc("/images/try-again.gif");
        break;
      case "wrong":
        setGifSrc("/images/wrong.gif");
        break;
      case "gameover":
        setGifSrc("/images/gameover.gif");
        break;
      case "the-end":
        setGifSrc("/images/the-end.gif");
        break;
      case "congrats":
        setGifSrc("/images/congrats.gif");
        break;
      default:
        setGifSrc("");
        break;
    }
  };

  // ëª¨ë“œê°€ ì„ íƒë˜ë©´ í€´ì¦ˆ ë°ì´í„° ì¤€ë¹„ ë° ì´ˆê¸°í™”
  useEffect(() => {
    if (!mode) return;

    let data;
    if (mode === "choice") data = multipleChoiceQuiz;
    else if (mode === "fill") data = fillInTheBlankQuiz;
    else data = mixedQuiz;

    const prepared = shuffleArray(prepareShuffledQuizData(data));
    setQuizData(prepared);
    setCurrentIndex(0);
    setSelected(null);
    setFillInput([]);
    setShowAnswer(false);
    setScore(0);
    setAnswerHistory(prepared.map(() => ({ tries: 0, isCorrect: false, selected: null })));
    setTimeLeft(TIME_LIMIT);
    setMessage("");
    setGifSrc("");
    setShowTryAgainBtn(false);
    setShowNextBtn(false);
    setCanRetry(false);
    setQuizEndTime(null);
    quizStartTime.current = Date.now();
  }, [mode, fillInTheBlankQuiz, mixedQuiz, multipleChoiceQuiz]);

  // ë‹µì•ˆ íˆìŠ¤í† ë¦¬ ë° ì ìˆ˜ ì—…ë°ì´íŠ¸
  const updateAnswerHistory = (idx, isCorrect, tries, selectedIdx) => {
    setAnswerHistory((prev) => {
      const newHistory = [...prev];
      newHistory[idx] = { tries, isCorrect, selected: selectedIdx };
      return newHistory;
    });
    if (isCorrect) setScore((prev) => prev + 1);
  };

  // ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬ í•¨ìˆ˜
  const handleTimeout = useCallback(() => {
    const { isCorrect, tries } = answerHistory[currentIndex] || { tries: 0, isCorrect: false };
    if (isCorrect) return;

    if (tries === 0) {
      setMessage("â° ì‹œê°„ ì´ˆê³¼! ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”.");
      setGifByResult("try-again");
      setShowTryAgainBtn(true);
      setCanRetry(false);
      updateAnswerHistory(currentIndex, false, tries + 1, selected);
    } else {
      setMessage("âŒ ì˜¤ë‹µì…ë‹ˆë‹¤! ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°€ì„¸ìš”.");
      setGifByResult("wrong");
      setShowAnswer(true);
      setShowNextBtn(true);
      setShowTryAgainBtn(false);
      setCanRetry(false);
      updateAnswerHistory(currentIndex, false, tries + 1, selected);
    }
  }, [answerHistory, currentIndex, selected]);

  // íƒ€ì´ë¨¸ ê´€ë¦¬ useEffect
  useEffect(() => {
    if (quizEndTime) return;

    const tries = answerHistory[currentIndex]?.tries || 0;
    const isCorrect = answerHistory[currentIndex]?.isCorrect || false;

    if (isCorrect || tries >= 2) {
      clearInterval(timerId.current);
      setTimeLeft(0);
      return;
    }

    setTimeLeft(TIME_LIMIT);
    clearInterval(timerId.current);

    timerId.current = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev === 1) {
          clearInterval(timerId.current);
          handleTimeout();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(timerId.current);
  }, [currentIndex, quizEndTime, answerHistory, handleTimeout]);

  // ê°ê´€ì‹ ì„ íƒ ì²˜ë¦¬
  const handleSelect = (idx) => {
    const tries = answerHistory[currentIndex]?.tries || 0;
    if (
      showAnswer ||
      answerHistory[currentIndex]?.isCorrect ||
      tries >= 2 ||
      timeLeft === 0 ||
      (tries === 1 && !canRetry)
    )
      return;

    setCanRetry(false);
    setSelected(idx);

    if (idx === current.answer) {
      setShowAnswer(true);
      setMessage(positiveMessages[Math.floor(Math.random() * positiveMessages.length)]);
      setGifByResult("correct");
      setShowTryAgainBtn(false);
      setShowNextBtn(true);
      updateAnswerHistory(currentIndex, true, tries + 1, idx);
    } else {
      if (tries === 0) {
        setMessage(retryMessages[Math.floor(Math.random() * retryMessages.length)]);
        setGifByResult("try-again");
        setShowTryAgainBtn(true);
        setShowAnswer(false);
        setCanRetry(false);
        updateAnswerHistory(currentIndex, false, tries + 1, idx);
      } else {
        setMessage("âŒ ì˜¤ë‹µì…ë‹ˆë‹¤! ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°€ì„¸ìš”.");
        setGifByResult("wrong");
        setShowAnswer(true);
        setShowNextBtn(true);
        setShowTryAgainBtn(false);
        updateAnswerHistory(currentIndex, false, tries + 1, idx);
      }
    }
  };

  // ì£¼ê´€ì‹ ë‹µì•ˆ í™•ì¸ ì²˜ë¦¬
  const handleCheckFillAnswer = () => {
    const tries = answerHistory[currentIndex]?.tries || 0;
    const inputValue = (fillInput[currentIndex] || "").trim();
    const correctAnswer = current.answer.trim();

    if (
      showAnswer ||
      answerHistory[currentIndex]?.isCorrect ||
      tries >= 2 ||
      timeLeft === 0 ||
      (tries === 1 && !canRetry)
    )
      return;

    setCanRetry(false);
    setSelected(inputValue);

    if (inputValue.toLowerCase() === correctAnswer.toLowerCase()) {
      setShowAnswer(true);
      setMessage(positiveMessages[Math.floor(Math.random() * positiveMessages.length)]);
      setGifByResult("correct");
      setShowTryAgainBtn(false);
      setShowNextBtn(true);
      updateAnswerHistory(currentIndex, true, tries + 1, inputValue);
    } else {
      if (tries === 0) {
        setMessage(retryMessages[Math.floor(Math.random() * retryMessages.length)]);
        setGifByResult("try-again");
        setShowTryAgainBtn(true);
        setShowAnswer(false);
        updateAnswerHistory(currentIndex, false, tries + 1, inputValue);
      } else {
        setMessage("âŒ ì˜¤ë‹µì…ë‹ˆë‹¤! ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°€ì„¸ìš”.");
        setGifByResult("wrong");
        setShowAnswer(true);
        setShowNextBtn(true);
        setShowTryAgainBtn(false);
        updateAnswerHistory(currentIndex, false, tries + 1, inputValue);
      }
    }
  };

  // ë‹¤ì‹œ ì‹œë„ ë²„íŠ¼ ì²˜ë¦¬
  const handleTryAgain = () => {
    setSelected(null);
    setMessage("");
    setGifSrc("");
    setShowTryAgainBtn(false);
    setCanRetry(true);
    setTimeLeft(TIME_LIMIT);
  };

  // ë‹¤ìŒ ë¬¸ì œ í˜¹ì€ ê²°ê³¼ë³´ê¸° ë²„íŠ¼ ì²˜ë¦¬
  const handleNext = () => {
    setSelected(null);
    setShowAnswer(false);
    setMessage("");
    setGifSrc("");
    setShowNextBtn(false);
    setCanRetry(false);
    setTimeLeft(TIME_LIMIT);

    if (currentIndex + 1 >= quizData.length) {
      setQuizEndTime(Date.now());
    } else {
      setCurrentIndex(currentIndex + 1);
    }
  };

  // ë‹¤ì‹œ ì‹œì‘ (ëª¨ë“œ ì„ íƒ ì´ˆê¸°í™”)
  const handleRestart = () => {
    setMode(null);
  };

  // ì£¼ê´€ì‹ ì…ë ¥ ë³€í™” ì²˜ë¦¬
  const onFillInputChange = (e) => {
    setFillInput((prev) => {
      const newFill = [...prev];
      newFill[currentIndex] = e.target.value;
      return newFill;
    });
  };

  return (
    <div className="app">
      {/* ëª¨ë“œ ì„ íƒ í™”ë©´ */}
      {!mode && (
        <>
          <h1>í”„ë¡œê·¸ë˜ë° í€´ì¦ˆ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”</h1>
          <div className="mode-select">
            <button
              onClick={() => setMode("choice")}
              className={mode === "choice" ? "selected" : ""}
            >
              ê°ê´€ì‹ ë¬¸ì œë§Œ
            </button>
            <button
              onClick={() => setMode("fill")}
              className={mode === "fill" ? "selected" : ""}
            >
              ì£¼ê´€ì‹ ë¬¸ì œë§Œ
            </button>
            <button
              onClick={() => setMode("mixed")}
              className={mode === "mixed" ? "selected" : ""}
            >
              ê°ê´€ì‹ + ì£¼ê´€ì‹ í˜¼í•©
            </button>
          </div>
        </>
      )}

      {/* í€´ì¦ˆ ì§„í–‰ í™”ë©´ */}
      {mode && !allDone && current && (
        <div className="quiz">
          <div className="quiz-progress">
            Quiz {currentIndex + 1} / {quizData.length} &nbsp;&nbsp;
            <span>ë‚¨ì€ ì‹œê°„: {timeLeft}ì´ˆ</span>
          </div>

          <h2>{current.question}</h2>

          {/* ê°ê´€ì‹ ë¬¸ì œ */}
          {!isFillQuestion && (
            <ul>
              {current.options.map((option, idx) => {
                let className = "option";
                if (showAnswer) {
                  if (idx === current.answer) className += " correct";
                  else if (idx === selected && idx !== current.answer) className += " wrong";
                  else className += " disabled";
                } else if (idx === selected) {
                  className += " selected";
                }

                return (
                  <li
                    key={idx}
                    className={className}
                    onClick={() => handleSelect(idx)}
                    aria-disabled={showAnswer}
                  >
                    {option}
                  </li>
                );
              })}
            </ul>
          )}

          {/* ì£¼ê´€ì‹ ë¬¸ì œ */}
          {isFillQuestion && (
            <div className="fill-question">
              <input
                type="text"
                value={fillInput[currentIndex] || ""}
                onChange={onFillInputChange}
                disabled={showAnswer}
                placeholder="ë‹µì„ ì…ë ¥í•˜ì„¸ìš”"
              />
              <button
                className="check-btn"
                onClick={handleCheckFillAnswer}
                disabled={showAnswer || !(fillInput[currentIndex]?.trim())}
              >
                í™•ì¸
              </button>
            </div>
          )}

          {/* í”¼ë“œë°± ë©”ì‹œì§€ ë° GIF */}
          {message && (
            <div className="feedback">
              <p>{message}</p>
              {gifSrc && <img src={gifSrc} alt="result gif" className="result-gif" />}
            </div>
          )}

          {/* ë‹¤ì‹œ ì‹œë„ ë²„íŠ¼ */}
          {showTryAgainBtn && (
            <button className="try-again-btn" onClick={handleTryAgain}>
              ë‹¤ì‹œ ì‹œë„í•˜ê¸°
            </button>
          )}

          {/* ë‹¤ìŒ ë¬¸ì œ or ê²°ê³¼ë³´ê¸° ë²„íŠ¼ */}
          {showNextBtn && (
            <button className="next-btn" onClick={handleNext}>
              {currentIndex + 1 === quizData.length ? "ê²°ê³¼ë³´ê¸°" : "ë‹¤ìŒ ë¬¸ì œ"}
            </button>
          )}
        </div>
      )}

      {/* ê²°ê³¼ í™”ë©´ */}
      {allDone && (
        <div className="result">
          <h2>í€´ì¦ˆ ì™„ë£Œ!</h2>
          <p>
            {quizData.length}ë¬¸ì œ ì¤‘ {score}ë¬¸ì œ ë§í˜”ìŠµë‹ˆë‹¤.
          </p>
          {allCorrect && (
            <>
              <p>ğŸŒŸ ëª¨ë“  ë¬¸ì œë¥¼ ë§íˆì…¨ë„¤ìš”! ëŒ€ë‹¨í•´ìš”! ğŸŒŸ</p>
              <img src="/images/congrats.gif" alt="ì¶•í•˜ gif" className="result-gif" />
            </>
          )}
          {allWrong && (
            <>
              <p>ë‹¤ìŒì—” ê¼­ ì„±ê³µí•  ìˆ˜ ìˆì–´ìš”! í¬ê¸°í•˜ì§€ ë§ˆì„¸ìš”! ğŸ’ª</p>
              <img src="/images/gameover.gif" alt="ê²Œì„ì˜¤ë²„ gif" className="result-gif" />
            </>
          )}
          {!allCorrect && !allWrong && <p>ì˜ í•˜ì…¨ì–´ìš”! ë” ë„ì „í•´ë³´ì„¸ìš”!</p>}
          <button className="retry-btn" onClick={handleRestart}>
            ë‹¤ì‹œ ì‹œì‘
          </button>
        </div>
      )}
    </div>
  );
}

style.scss

.app {
  max-width: 600px;
  margin: 2rem auto;
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  text-align: center;
  background: #fff;
  padding: 1rem;
  border-radius: 12px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.quiz {
  background: #f9f9f9;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

.quiz-progress {
  font-weight: bold;
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
  color: #333;
}

ul {
  list-style: none;
  padding: 0;

  .option {
    background: #fff;
    padding: 1rem;
    margin: 0.5rem 0;
    border: 1px solid #ddd;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s, border-color 0.3s;

    &:hover {
      background: #f0f0f0;
    }

    &.correct {
      background-color: #d4edda;
      border-color: #28a745;
      font-weight: bold;
      color: #155724;
    }

    &.wrong {
      background-color: #f8d7da;
      border-color: #dc3545;
      font-weight: bold;
      color: #721c24;
    }

    &.disabled {
      pointer-events: none;
      cursor: default;
      background: #f9f9f9 !important;
      color: #999;
    }
  }
}

.fill-question {
  display: flex;
  justify-content: center;
  gap: 0.5rem;

  input[type="text"] {
    flex: 1;
    padding: 0.7rem;
    font-size: 1rem;
    border-radius: 8px;
    border: 1px solid #ccc;
  }

  .check-btn {
    padding: 0.7rem 1.2rem;
    border: none;
    border-radius: 8px;
    background-color: #007bff;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s;

    &:hover {
      background-color: #0056b3;
    }

    &:disabled {
      background-color: #999;
      cursor: not-allowed;
    }
  }
}

.feedback {
  margin-top: 1rem;

  p {
    font-size: 1.1rem;
  }

  .result-gif {
    max-width: 100%;
    margin-top: 1rem;
    border-radius: 10px;
  }
}

.try-again-btn,
.next-btn,
.finish-btn,
.retry-btn {
  margin-top: 1rem;
  padding: 0.5rem 1.2rem;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 6px;
  border: none;
  background-color: #007bff;
  color: white;
  transition: background-color 0.3s ease;
  display: inline-block;
}

.try-again-btn:hover,
.next-btn:hover,
.finish-btn:hover,
.retry-btn:hover {
  background-color: #0056b3;
}

.result {
  margin-top: 2rem;
  text-align: center;

  h2 {
    margin-bottom: 1rem;
  }

  p {
    font-size: 1.1rem;
    margin: 0.5rem 0;
  }
}

/* ë²„íŠ¼ ì„ íƒ UI */
.mode-select {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-bottom: 1.5rem;

  button {
    padding: 0.6rem 1.5rem;
    font-size: 1rem;
    cursor: pointer;
    border-radius: 8px;
    border: 2px solid #007bff;
    background-color: white;
    color: #007bff;
    font-weight: 600;
    transition: background-color 0.3s, color 0.3s;
  }

  button.selected,
  button:hover {
    background-color: #007bff;
    color: white;
  }
}

index.html

<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="./public/images/quiz.jpg" />
    <title>React í€´ì¦ˆ</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.jsx"></script>
  </body>
</html>

App.css

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


